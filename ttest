function equal_exponenitial_digital_sums(n::Integer)
    equalpows = [(1, BigInt(n))]
    npow, misses, nsum = 2, 0, sum(digits(n))
    while misses < n + 20
        nexp = BigInt(n) ^ npow
        if sum(digits(nexp)) == nsum
            push!(equalpows, (npow, nexp))
        else
            misses += 1
        end
        npow += 1
    end
    length(equalpows) > 1 && println(equalpows)
    return equalpows
end

const digittalpowcounts = filter(a -> length(a) > 1, map(equal_exponenitial_digital_sums, 1:6000))
const multipowcounts = map(a -> length(a) > 2, digitalpowcounts)

println("First twenty-five integers that are equal to the digital sum of that integer raised to some power:")
foreach(p -> print(rpad(p[2][1][2], 6), p[1] % 10 == 0 ? "\n" : ""), digitalpowcounts[1:25])
println("\nFirst thirty that satisfy that condition in three or more ways:")
foreach(a -> println(a[1][2], " => ", a[2:end]), multipowcounts)
