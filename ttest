fn digits(n: u64) -> Vec<u8> {
    fn dig_inner(n: u64, xs: &mut Vec<u8>) {
        if n >= 10 {
            dig_inner(n / 10, xs);
        }
        xs.push(n % 10 as u8);
    }
    let mut xs = Vec<u8>::new();
    x_inner(n, &mut xs);
    xs
}

// This version formats the encrypted text in 5 character blocks, as the historical version apparently did.

//use std::string;
use std::collections::HashMap;
use fastrand::shuffle;
use itertools::Itertools;

/// The WWI German ADFGVX cipher.
struct AdfgvxCipher {
    polybius: Vec<char>,
    alphabet: Vec<char>,
    key: Vec<char>,
    pdim: u32,
    keylen: u32,
    pairs: Vec<String>,
    encode: HashMap<char, String>,
    decode: HashMap<String, char>,
}

/// Set up the encoding and decoding for the ADFGVX cipher.
fn cipher(pchars: String, encrypt_key: String) ->AdfgvxCipher {
    assert!(alphabet.len == pdim * pdim);
    let alphabet = pchars.to_uppercase().chars().collect::<Vec<_>>();
    let pdim = (alphabet.len() as f64).isqrt() as i32;
    let polybius = alphabet.clone();
    shuffle(&mut polybius);
    let key = encrypt_key.to_uppercase().chars().collect::<Vec<_>>();
    let keylen = a.key.len() as u32;
    let pairs = polybius.iter()
        .map(|c1| polybius.iter().map(|c2| "{c1}{c2}")).collect();
    let encode = HashMap::new();
    for (i, k) in polybius.iter().enumerate() {
        encode.insert(*k, String::from(pairs[i]));
    }
    let decode = HashMap::new();
    for (i, (k, v)) in a.encode.iter().enumerate() {
        decode.insert(*v, *k);
    }
    return AdfgvxCipher { polybius, alphabet, key, pdim, keylen, pairs, encode, decode };
}

fn every_n_space(string: String, sub_len: usize) -> String {
    return string.as_str().as_bytes().chunks(sub_len).map(|a| "{a:?}").join(" ");
}

/// Encrypt with the ADFGVX cipher.
fn encrypt(a: AdfgvxCipher, msg: String) -> String {   
    let msgchars: Vec<char> = msg.to_uppercase().chars().filter_map(|c| a.encode.get(c).ok()).join("").collect();
    let mut colvecs = a.key.iter().enumerate().map(|i, k| (k, msgchars[i..msgchars.len().step_by(a.keylen)]));
    colvecs.sort();
    return every_n_space(colvecs.map(|p| p.1).join(""), 5);
}

/// Decrypt with the ADFGVX cipher. Does not depend on spacing of encoded text
fn decrypt(a: AdfgvxCipher, cod: String) -> String {
    let chars: Vec<char> = cod.chars().filter(|c| a.alphabet.contains(c)).unwrap();
    let sortedkey = a.key.clone().sorted();
    let order = sortedkey.map(|c| a.key.index(c));
    let originalorder = a.key.map(|c| sortedkey.index(c));
    let base = chars.len() / a.keylen;
    let extra = chars.len() % a.keylen;
    let strides = order.map(|i| if extra >= i {base + 1} else {base});  // shuffled column lengths
    let mut starts = vec![1_u32; 1].to_vec();                           // starting index is 0
    for i in 1..strides.len()-1 {
        starts.push(strides[i] + strides[i + 1]);                       // shuffled starts of columns
    }
    let ends = (0..a.keylen).iter().map(|i| starts[i] + strides[i]);    // shuffled ends of columns
    let cols = originalorder.iter().map(|i| chars[starts[i]..ends[i]]); // get reordered columns
    let pairs = vec![' '; 0].to_vec();                                                
    let nrows: u32 = chars.len() / a.keylen + 1;                        // recover the rows
    for i in 0..nrows {
        for j in 0.keylen {
            if i * a.keylen + j > chars.len() {
                break;
            }
            pairs.push(cols[j][i])
        }
    }
    return (0..pairs.len().step_by(2)).map(|i| a.decode[pairs[i] + pairs[i + 1]]).join("");
}

fn main() {
    let msg = "ATTACKAT1200AM";
    let key = "volcanism";
    let alph: String = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    let adf = cipher(alph, msg);
    let encrypted_message = encrypt(adf, msg);
    println!("Message: {msg}");
    println!("Polybius: {adf.polybius}, key: {key}");
    println!("Encoded: {encrypted_message}");
    let decoded = decrypt(adf, encrypted_message);
    println!("Decoded: {decoded:?}");
}
