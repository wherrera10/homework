struct SquareSums
    sums::Vector{Tuple{Int, Int, Int}}
    SquareSums() = new(Tuple{Int, Int, Int}[])
end

function Base.iterate(sqs::SquareSums, state = 1)
    while isempty(sqs.sums) || state^2 <= sqs.sums[1][1]
        push!(sqs.sums, (state * state, state, 0))
        state += 1
    end
    sort!(sqs.sums)
    nextsum, xy = sqs.sums[1][1], Tuple{Int, Int}[]
    while !isempty(sqs.sums) && sqs.sums[1][1] == nextsum # pop all vectors with same length
        _, a, b = popfirst!(sqs.sums)
        push!(xy, (a, b), (b, a), (-a, b), (a, -b))
        if a > b
            push!(sqs.sums, (a * a + (b + 1) * (b + 1), a, b + 1))
        end
    end
    return unique(xy), state
end

function babylonian_spiral(N)
    sqs = SquareSums()
    xydeltas = [(0, 0)]
    for xys in sqs
        lastdx, lastdy = xydeltas[end]
        theta = atan(lastdy, lastdx)
        sort!(xys, by = p -> mod1(theta - atan(p[2], p[1]), 2Ï€))
        push!(xydeltas, xys[begin])
        length(xydeltas) >= N && break
    end
    return accumulate((a, b) -> (a[1] + b[1], a[2] + b[2]), @view xydeltas[begin:N])
end

println("The first 40 Babylonian spiral points are:")
@show babylonian_spiral(40)
