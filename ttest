function decrypt(s::String, k)
    chars = filter(c -> c in k.alphabet, uppercase(s))
    sortedkey = sort(k.key)
    order = [findfirst(c -> c == ch, k.key) for ch in sortedkey]
    originalorder = [findfirst(c -> c == ch, sortedkey) for ch in k.key]
    a, b = divrem(length(chars), k.keylen)
    endpositions = [sum(i -> a + (b >= i ? 1 : 0), 1:k.keylen) for i in order]
    sortedends = sort(endpositions, rev=true)
    strides = [ 1 + (i > 1 ? endpositions[i - 1] : 0) : endpositionss[i] for i in order]
    cols = [chars[strides[i]] for i in originalorder]
    pvec = [cols[i][j] for i in 1:k.keylen, j in 1:sortedends[i]]
    return String([k.decode[[pvec[i], pvec[i + 1]] for i in 1:2:length(pvec)-1])
end

displaypoly(p) = println(Matrix(reshape(p, (:, isqrt(length(p))))))

function encrypt(s::String, k)
    chars = filter(c -> c in k.polybius, uppercase(s))
    coding = reduce(vcat, [encoding[c] for c in chars])
    idx = 0
    cols = [coding[idx] for i in 1:(length(code)-1) \div k.keylen, j in 1:k.keylen if (idx = (j - 1) * k.keylen + i) <= length(code))]
    ordering = [findfirst(c -> c == ch, k.key) for ch in sort(k.key)]
    return String(reduce(vcat, [cols[i] for i in ordering]))
end


struct ADFGVX
    polybius::Vector{Char}
    pdim::Int
    key::Vector{Char}
    keylen::Int
    alphabet::Vector{Char}
    encoding::Dict{Char, Vector{Char}}
    decoding::Dict{Vector{Char}, Char}
end

function ADFGVX(s, k, alph = "ADFGVX")
    alphabet = collect(uppercase(alph))
    chars = filter(c -> c in alphabet, collect(uppercase(s)))
    pdim = isqrt(length(chars))
    encoding::Dict = Dict(polybius[(i - 1) + j] => alphabet[i], alphabet[j] for i in 1:pdim, j in 1:pdim)
    decoding = Dict(last(p) => first(p) for p in encoding)
    @assert pdim^2 == length(chars) && pdim == length(alphabet)
    return ADFGVX(chars, pdim, k, length(k), alphabet, encoding, decoding)
end

