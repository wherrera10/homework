import Base.length, Base.*, Base.string

""" A Perm is a 1-based, gapless range of integers in any order. """
mutable struct Perm
    a::Vector{Int}
    function Perm(arr::Vector{Int})
        length(arr) != length(unique(arr)) && error("All elements must be unique")
        sort(arr) != collect(1:length(arr)) && error("$arr must be a permutation of a 1 based integer range")
        return new(arr)
    end
end

Base.length(p::Perm) = length(p.a)

""" Make a Perm from an iterable of any type"""
function Perm(iterable)
    items = unique(collect(iterable))
    itemtoint = Dict(p[2] => p[1] for p in enumerate(items))
    return Perm([itemtoint[c] for c in items])
end

""" get cycles of Perm as a vector of integer vectors, optionally with singles """
function permcycles(p::Perm, includesingles = false)
    len = length(p)
    cycles = Vector{Vector{Int}}()
    remaining, i = trues(len), 1
    while !(i isa Nothing)
        remaining[i] = false
        nextcycle = [i]
        j = p[i]
        while j != i
            push!(nextcycle, j)
            remaining[j] = false
            j = p[j]
        end
        push!(cycles, nextcycle)
        i = findnext(remaining, i)
    end
    return includesingles ? cycles : filter(c -> length(c) > 1, cycles)
end

function Base.:*(p1:: Perm, p2::Perm)
    length(p1) != length(p2) && error("To compose permutations, they must be the same length")
    a = [p1.a[p2.a[i]] for i in eachindex(p1)]
    return Perm(a)
end

""" Perm prints in cycle format """
function Base.print(io::IO, p::Perm; printsingles = false)
    if length(p) == 0
        print("()")
    end
    cycles = permcycles(p, includesingles = printsingles)
    for c in cycles
        print(io, "(" * string(c)[begin+1:end-1] * ")")
    end
end
