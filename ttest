struct PositType3{T<:Integer}
  numbits::UInt16
  es::UInt16
  bits::T
  PositType3(nb, ne, i) = new{typeof(i)}(UInt16(nb), UInt16(ne), i)
end

""" From posithub.org/docs/Posits4.pdf """
function Base.Rational(p::PositType3)
s = signbit(signed(p.bits))                      # s for S signbit, is 1 if negative
pabs = p.bits << 1                       # shift off signbit (adds a 0 to F at LSB)
pabs == 0 && return s ? 1 // 0 : 0 // 1  # if p is 0, return 0 if s = 0, error if s = 1
expsign = signbit(signed(pabs))                  # exponent sign from 2nd bit now in MSB location
k = expsign == 1 ? leading_ones(pabs) : leading_zeros(pabs) # regime R bit count
scaling = 2^p.es * (expsign == 0 ? -1 : 1)
pabs <<= (k + 1)                         # shift off unwanted R bits
pabs >>= (k + 2)                         # shift back without the extra LSB bit
fsize = p.numbits - k - p.es - 2         # check how many F bits are actually explicit
fsize <= 0 && return 0 // 1              # missing F is 0
f = (pabs & (2^fsize - 1)) // 2^fsize     # Get F value. Can be missing -> 0
e = pabs >> fsize                        # Get E value. 
pw = (1 - 2s) * (scaling * k + e + s)
return pw >= 0 ? ((1 - 3s) + f) * 2^pw // 1 : ((1 - 3s) + f) // 2^(-pw)
end

@show Rational(PositType3(16, 3, 0b0000110111011101)) == 477 // 134217728

const tests = [
  (16,3,0b0000110111011101),
  (16,3,0b1000000000000000),
  (16,3,0b0000000000000000),
  (16,1,0b0110110010101000),
  (16,1,0b1001001101011000),
  (16,2,0b0000000000000001),
  (16,0,0b0111111111111111),
  (16,6,UInt128(0b0111111111111110)),
  (8,1,0b01000000),
  (8,1,0b11000000),
  (8,1,0b00110000),
  (8,1,0b00100000),
  (8,2,0b00000001),
  (8,2,0b01111111),
  (8,7,0b01111110),
  (32,2,0b00000000000000000000000000000001),
  (32,2,0b01111111111111111111111111111111),
  (32,5,0b01111111111111111111111111111110),
]

for t in tests
    @show string(t[3], base=2), Rational(PositType3(t...))
end
