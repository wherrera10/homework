fn digits(n: u64) -> Vec<u8> {
    fn dig_inner(n: u64, xs: &mut Vec<u8>) {
        if n >= 10 {
            dig_inner(n / 10, xs);
        }
        xs.push(n % 10 as u8);
    }
    let mut xs = Vec<u8>::new();
    x_inner(n, &mut xs);
    xs
}


// This version formats the encrypted text in 5 character blocks, as the historical version apparently did.

//use std::string;
use std::ops::{Index, Add};
use std::collections::HashMap;
use fastrand::shuffle;
use itertools::Itertools;

/// The WWI German ADFGVX cipher.
struct AdfgvxCipher {
    polybius: Vec<char>,
    alphabet: Vec<char>,
    key: Vec<char>,
    pdim: usize,
    keylen: usize,
    pairs: Vec<String>,
    encode: HashMap<char, String>,
    decode: HashMap<String, char>,
}

/// Set up the encoding and decoding for the ADFGVX cipher.
fn cipher(allowed_chars: String, encrypt_key: String) ->AdfgvxCipher {
    let alphabet = allowed_chars.to_uppercase().chars().collect::<Vec<_>>();
    let pdim = (alphabet.len() as f64).sqrt() as usize;
    assert!(alphabet.len() == pdim * pdim);
    let mut polybius = alphabet.clone();
    shuffle(&mut polybius);
    let key = encrypt_key.to_uppercase().chars().collect::<Vec<_>>();
    let keylen = key.len();
    let pairs: Vec<String> = polybius.iter()
        .map(|c1| polybius.iter().map(|c2| "{c1}{c2}").collect()).collect();
    let mut encode = HashMap::new();
    for (i, k) in polybius.iter().enumerate() {
        encode.insert(*k, String::from(pairs[i]));
    }
    let mut decode = HashMap::new();
    for (i, (k, v)) in encode.iter().enumerate() {
        decode.insert(*v, *k);
    }
    return AdfgvxCipher { polybius, alphabet, key, pdim, keylen, pairs, encode, decode };
}

/// Encrypt with the ADFGVX cipher.
fn encrypt(a: AdfgvxCipher, msg: String) -> String {
    let umsg: Vec<char> = msg.clone().to_uppercase().chars()
        .filter(|c| a.encode.contains_key(c)).collect();
    let mut fractionated: Vec<char> = umsg.iter().map(|c| *a.encode.get(c).unwrap())
        .collect::<Vec<String>>().join("").chars().collect();
    let mut flen = fractionated.len();
    let ncols = a.keylen;
    let extra = fractionated.len() % ncols;
    if extra > 0 {
        fractionated.append('\u{00}'.repeat(flen - extra);
        flen = fractionated.len();
    }
    let nrows = fractionated.len() / ncols;
    let mut sortkey = a.key.clone().chars().collect();
    sortkey.sort();
    let mut ciphertext = vec![' '; 0].to_vec();
    let mut textlen = 0;
    for j in 0..ncols {
        let k = sortkey.iter().position(|c| c == a.key[j]);
        for i in 0..nrows {
            ch = fractionated[k * ncols + j];
            if ch != '\u{00}' {
                ciphertext.push(ch);
                textlen += 1;
                if textlen % 5 == 0 {
                    ciphertext.push(' ');
                }
        }
    }
    return String::from(ciphertext);
}

/// Decrypt with the ADFGVX cipher. Does not depend on spacing of encoded text
fn decrypt(a: AdfgvxCipher, cod: String) -> String {
    let chars: Vec<char> = cod.chars().filter(|c| a.alphabet.contains(c)).collect();
    let ncols = a.keylen;
    let nrows = chars.len() / ncols;
    let mut sortedkey = a.key.clone().chars().collect();
    sortedkey.sort();
    let mut fractionated = vec![' '; 0].to_vec();
    for j in 0..ncols {
        let k = a.key.iter().position(|c| c == sortedkey[j]);
        for i in 0..nrows {
            let c = chars[i * ncols + k];
            if c != '\{00}' {
                fractionated.push(c);
            }
        }
    }
    let mut decoded = vec![' '; 0].to_vec();
    for i in 0..fractionated.len().step_by(2) {
        s = String::from(fractionated[i..i+1]);
        decoded.push(a.decode.get(s).unwrap());
    }
    return String::from(decoded);
}

fn main() {
    let msg = String::from("ATTACKAT1200AM");
    let encrypt_key = String::from("volcanism");
    let allowed_chars: String = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    let adf = cipher(allowed_chars, encrypt_key);
    let encrypted_message = encrypt(adf, msg);
    println!("Message: {msg}");
    println!("Polybius: {:?}, key: {encrypt_key}", adf.polybius);
    println!("Encoded: {encrypted_message}");
    let decoded = decrypt(adf, encrypted_message);
    println!("Decoded: {decoded:?}");
}
