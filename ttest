
function aupto(lim::T, mx::T = zero(T)) where T <: Integer
    lim < 2 && return [one(T)]
    v, t = [one(T)], one(T)
    mx == 0 && (mx = lim)
    for k in 2:mx
        t *= k
        t > lim && break
        append!(v, [t * rest for rest in aupto(lim รท t, t)])
    end
    return unique(sort!(v))
end

const factorials = map(factorial, 2:18)

function factor_into_factorials(n::T, idx = length(factorials)) where T <: Integer
    idx < 1 && return Pair{T, Int}[] 
    m = n
    fac_exp_pairs = Pair{T, Int}[]
    for i in idx:-1:1
        expo = 0
        while m % factorials[i] == 0
            expo += 1
            m รท= factorials[i]
        end
        if expo > 0
            push!(fac_exp_pairs, factorials[i] => expo)
        end
    end
    m > 1 && return factor_into_factorials(n::T, idx - 1)
    return fac_exp_pairs
end

arr = aupto(2^53)

println(arr[[800, 1800, 2800, 3800]])

println([factor_into_factorials(n) for n in arr[[800, 1800, 2800, 3800]]])
