using Counters, Formatting, Primes

struct Sisyphus end

function base.iterate(s::Sisyphus, (n, p) = (0, 0)
    if n == 0
        return (1, 0), (1, 0)
    else
        if isodd(n)
            p = nextprime(p + 1)
            n = n + p
        else:
            n = \div= 2
        end
        return (n, p), (n, p)
    end
end

coun = Counter{Int}()
println("The first 100 members of the Sisyphus sequence are:")
for (i, (n, p)) in eneumerate(Sisyphus())
    coun[n] += 1
    if i < 101
        print(rpad(n, 4), i % 10 == 0 ? "\n" : "")
    elseif i in [1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000]
        print("\n$(i)th number: : ", format(n, commas = true), "   highest prime needed: ",
           format(p, commas = true))
    end
    if i == 1000000000
        println("These numbers under 250 do not occur in the first 100,000,000 terms:")
    println("    ", filter(!haskey(coun, n), 1:249), "\n")
    print("")

    most_common = sisyphus_lt_250.most_common(1)[0][1]
    print("These numbers under 250 occur the most in the first 100,000,000 terms:")
    print(
        f"  {[n for n, c in sisyphus_lt_250.items() if c == most_common]} "
        f"all occur {most_common} times."
    )


using Printf

function aitken(f, p0)
    p1 = f(p0)
    p2 = f(p1)
    return p0 - (p1 - p0)^2 / (p2 - 2 * p1 + p0)
end

function steffensen_aitken(f, pinit, tol, maxiter)
    p0 = pinit
    p = aitken(f, p0)
    iter = 1
    while abs(p - p0) > tol && iter < maxiter
        p0 = p
        p = aitken(f, p0)
        iter += 1
    end
    abs(p - p0) > tol && return NaN
    return p
end

function deCasteljau(c0, c1, c2, t)
    s = 1.0 - t
    return s * (s * c0 + t * c1) + t * (s * c1 + t * c2)
end

xConvexLeftParabola(t) = deCasteljau(2, -8, 2, t)
yConvexRightParabola(t) = deCasteljau(1, 2, 3, t)
implicit_equation(x, y) = 5x^2 + y - 5

f(t) = implicit_equation(xConvexLeftParabola(t), yConvexRightParabola(t)) + t

function test_steffensen(tol = 0.00000001, iters = 1000, stepsize = 0.1)
    for t0 in 0:stepsize:1
        @printf("t0 = %0.1f : ", t0)
        t = steffensen_aitken(f, t0, tol, iters)
        if isnan(t)
            @printf("no answer\n")
        else
            x = xConvexLeftParabola(t)
            y = yConvexRightParabola(t)
            if abs(implicit_equation(x, y)) <= tol
                @printf("intersection at (%f, %f)\n", x, y)
            else
                @printf("spurious solution\n");
            end
        end
    end
    return 0
end

test_steffensen()

function jp(limit::T) where T <: Integer
    res = map(factorial, T(1):T(18))
    k = 2
    while k < length(res)
        rk = res[k]
        for j = 2:length(res)
            kl = res[j] * rk
            kl > limit && break
            while kl <= limit && kl âˆ‰ res
                push!(res, kl)
                kl *= rk
             end
        end
        k += 1
    end
    return sort!((sizeof(T) > sizeof(Int) ? T : Int).(res))
end

@show jp(UInt(2^53))
@time jp(UInt(2^53))
