
function aupto(lim::T, mx::T = zero(T)) where T <: Integer
    lim < 2 && return [one(T)]
    v, t = [one(T)], one(T)
    mx == 0 && (mx = lim)
    for k in 2:mx
        t *= k
        t > lim && break
        append!(v, [t * rest for rest in aupto(lim รท t, t)])
    end
    return unique(sort!(v))
end

const factorials = map(factorial, 2:18)

function factor_into_factorials(n::T)
    m = n
    fac_exp_pairs = Pair{T, Int}[]
    for idx in length(factorials):-1:1
        q, r = divrem(m, factorials[idx])
        if q > 0 && r == 0
            push!(fac_exp_pairs, factorials[idx] => q)
            m -= factorials[idx] * q
        end
    end
    m > 0 && error("$n does not decompose into the factorials $factorials")
    return fac_exp_pairs
end

arr = aupto(2^53)

println(arr[[800, 1800, 2800, 3800]])

println([factor_into_factorials(n) for n in arr[[800, 1800, 2800, 3800]]])
