using JuMP, Ipopt
n = 5
n! = factorial(n)
model = Model(Ipopt.Optimizer)
@variable(model, X[1:n, 1:n])
@variable(model, y[1:n])
@expression(model, z[i=1:n], sum(X[i, :]))
@NLexpression(
    model,
    expr[i=1:n],
    z[i]^4 / n! - sum(X[i, j] * z[j]^4 for j in 1:n) / (n! * (n + 1)),
)
@NLconstraint(model, sum(y[i] * expr[i] for i in 1:n) == 1)
The trick is to realize that you can’t construct nonlinear expressions outside the macros, you can’t use linear algebra like X * z, and you can’t use function calls like factorial(n) inside the macro.



using Printf

function aitken(f, p0)
    p1 = f(p0)
    p2 = f(p1)
    return p0 - (p1 - p0)^2 / (p2 - 2 * p1 + p0)
end

function steffensen_aitken(f, pinit, tol, maxiter)
    p0 = pinit
    p = aitken(f, p0)
    iter = 1
    while abs(p - p0) > tol && iter < maxiter
        p0 = p
        p = aitken(f, p0)
        iter += 1
    end
    abs(p - p0) > tol && return NaN
    return p
end

function deCasteljau(c0, c1, c2, t)
    s = 1.0 - t
    return s * (s * c0 + t * c1) + t * (s * c1 + t * c2)
end

xConvexLeftParabola(t) = deCasteljau(2, -8, 2, t)
yConvexRightParabola(t) = deCasteljau(1, 2, 3, t)
implicit_equation(x, y) = 5x^2 + y - 5

f(t) = implicit_equation(xConvexLeftParabola(t), yConvexRightParabola(t)) + t

function test_steffensen(tol = 0.00000001, iters = 1000, stepsize = 0.1)
    for t0 in 0:stepsize:1
        @printf("t0 = %0.1f : ", t0)
        t = steffensen_aitken(f, t0, tol, iters)
        if isnan(t)
            @printf("no answer\n")
        else
            x = xConvexLeftParabola(t)
            y = yConvexRightParabola(t)
            if abs(implicit_equation(x, y)) <= tol
                @printf("intersection at (%f, %f)\n", x, y)
            else
                @printf("spurious solution\n");
            end
        end
    end
    return 0
end

test_steffensen()

function jp(limit::T) where T <: Integer
    res = map(factorial, T(1):T(18))
    k = 2
    while k < length(res)
        rk = res[k]
        for j = 2:length(res)
            kl = res[j] * rk
            kl > limit && break
            while kl <= limit && kl ∉ res
                push!(res, kl)
                kl *= rk
             end
        end
        k += 1
    end
    return sort!((sizeof(T) > sizeof(Int) ? T : Int).(res))
end

@show jp(UInt(2^53))
@time jp(UInt(2^53))
