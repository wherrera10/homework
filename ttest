fn digits(n: u64) -> Vec<u8> {
    fn dig_inner(n: u64, xs: &mut Vec<u8>) {
        if n >= 10 {
            dig_inner(n / 10, xs);
        }
        xs.push(n % 10 as u8);
    }
    let mut xs = Vec<u8>::new();
    x_inner(n, &mut xs);
    xs
}


// This version formats the encrypted text in 5 character blocks, as the historical version apparently did.

//use std::string;
use std::ops::{Index, Add};
use std::collections::HashMap;
use fastrand::shuffle;
use itertools::Itertools;

/// The WWI German ADFGVX cipher.
struct AdfgvxCipher {
    polybius: Vec<char>,
    alphabet: Vec<char>,
    key: Vec<char>,
    pdim: usize,
    keylen: usize,
    pairs: Vec<String>,
    encode: HashMap<char, String>,
    decode: HashMap<String, char>,
}

/// Set up the encoding and decoding for the ADFGVX cipher.
fn cipher(allowed_chars: String, encrypt_key: String) ->AdfgvxCipher {
    let alphabet = allowed_chars.to_uppercase().chars().collect::<Vec<_>>();
    let pdim = (alphabet.len() as f64).sqrt() as usize;
    assert!(alphabet.len() == pdim * pdim);
    let mut polybius = alphabet.clone();
    shuffle(&mut polybius);
    let key = encrypt_key.to_uppercase().chars().collect::<Vec<_>>();
    let keylen = key.len();
    let pairs: Vec<String> = polybius.iter()
        .map(|c1| polybius.iter().map(|c2| "{c1}{c2}").collect()).collect();
    let mut encode = HashMap::new();
    for (i, k) in polybius.iter().enumerate() {
        encode.insert(*k, String::from(pairs[i]));
    }
    let mut decode = HashMap::new();
    for (i, (k, v)) in encode.iter().enumerate() {
        decode.insert(*v, *k);
    }
    return AdfgvxCipher { polybius, alphabet, key, pdim, keylen, pairs, encode, decode };
}

/// Encrypt with the ADFGVX cipher.
fn encrypt(a: AdfgvxCipher, msg: String) -> String {
    let umsg: Vec<char> = msg.clone().to_uppercase().chars()
        .filter(|c| a.encode.contains_key(c)).collect();
    let mut fractionated: Vec<char> = umsg.iter().map(|c| *a.encode.get(c).unwrap())
        .collect::<Vec<String>>().join("").chars().collect();
    let mut flen = fractionated.len();
    let ncols = a.keylen;
    let extra = fractionated.len() % ncols;
    if extra > 0 {
        fractionated.append('\u{00}'.repeat(flen - extra);
        flen = fractionated.len();
    }
    let nrows = fractionated.len() / ncols;
    let mut sortkey = a.key.clone().chars().collect();
    sortkey.sort();
    let mut ciphertext = vec![' '; 0].to_vec();
    let mut textlen = 0;
    for j in 0..ncols {
        let k = sortkey.iter().position(|c| c == a.key[j]);
        for i in 0..nrows {
            ch = fractionated[k * ncols + j];
            if ch != '\u{00}' {
                ciphertext.push(rows[k][j]);
                textlen += 1;
                if textlen % 5 == 0 {
                    ciphertext.push(' ');
                }
        }
    }
    return String::from(ciphertext);
}

/// Decrypt with the ADFGVX cipher. Does not depend on spacing of encoded text
fn decrypt(a: AdfgvxCipher, cod: String) -> String {
    let chars: Vec<char> = cod.chars().filter(|c| a.alphabet.contains(c)).collect();
    let sortedkey = a.key.clone();
    sortedkey.sort();
    let order = sortedkey.iter().map(|c| a.key.iter().position(|x| x == c)).collect();
    let originalorder = a.key.iter().map(|c| sortedkey.find(c)).collect();
    let base = chars.len() / a.keylen;
    let extra = chars.len() % a.keylen;
    let strides = order.map(|i| if extra >= i {base + 1} else {base});  // shuffled column lengths
    let mut starts = vec![1_u32; 1].to_vec();                        // starting index is 0
    for i in 1..strides.len()-1 {
        starts.push(strides[i] + strides[i + 1]);                              // shuffled starts of columns
    }
    let ends = (0..a.keylen).map(|i| starts[i] + strides[i]).collect(); // shuffled ends of columns
    let cols = originalorder.iter().map(|i| chars[starts[i]..ends[i]]);        // get reordered columns
    let pairs = vec![' '; 0].to_vec();                                                
    let nrows: usize = chars.len() / a.keylen + 1;                            // recover the rows
    for i in 0..nrows {
        for j in 0..a.keylen {
            if i * a.keylen + j > chars.len() {
                break;
            }
            pairs.push(cols[j][i])
        }
    }
    return (0..pairs.len()).step_by(2).map(|i| a.decode[&[pairs[i], pairs[i + 1]]
        .iter().join("")]).collect().join("");
}

fn main() {
    let msg = String::from("ATTACKAT1200AM");
    let encrypt_key = String::from("volcanism");
    let allowed_chars: String = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    let adf = cipher(allowed_chars, encrypt_key);
    let encrypted_message = encrypt(adf, msg);
    println!("Message: {msg}");
    println!("Polybius: {:?}, key: {encrypt_key}", adf.polybius);
    println!("Encoded: {encrypted_message}");
    let decoded = decrypt(adf, encrypted_message);
    println!("Decoded: {decoded:?}");
}
