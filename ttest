struct Posit
    UInt numbits;
    UInt bits;
end

function Base.sign(p::Posit)
    return iszero(p.bits) ? 0 : (p.bits > 2^(p.numbits - 1)) ? -1 : +1
end

function torational(p::Posit)
    iszero(p.bits) && return 0
    mask = 2^(p.numbits - 1)
    p.bits == mask && return Inf
    r = sign(p)
    n = r >= 0 ? p.bits : (2^p.numbits - 1) âŠ» p.bits
    bcount = 0
    mask >>= 1
    firstbit = (n & mask) != 0
    while n & mask == firstbit && mask != 0
        bcount +=1
        mask >>= 1
    end
  my $m = $count;
  my $k = $first-bit ?? $m - 1 !! -$m;
  $r *= 2**($k*2**$es);
  return $r unless $mask > 1;
  $mask +>= 1;
  $count = 0;
  my UInt $exponent = 0;
  while $mask && $count++ < $es {
    $exponent +<= 1;
    $exponent +|= 1 if $n +& $mask;
    $mask +>= 1;
  }
  $r *= 2**$exponent;
  my $fraction = 1.FatRat;
  while $mask {
    (state $power-of-two = 1) +<= 1;
    $fraction += 1/$power-of-two if $n +& $mask;
    $mask +>= 1;
  }
  $r *= $fraction;

  return $r;
}

CHECK {
  use Test;
  # example from L<http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf>
  is Posit[16, 3]
    .new(UInt => 0b0000110111011101)
    .FatRat, 477.FatRat/134217728;
}
