function equal_digitalsum_exponents(n::Integer)
    equalpows = Int[]
    n < 2 && return equalpows
    npow, misses = 2, 0
    while misses < n + 20
        psum = sum(digits(BigInt(n) ^ npow))
        if npow > 10 && psum > 2 * n
            break
        elseif  psum == n
            push!(equalpows, npow)
        else
            misses += 1
        end
        npow += 1
    end
    !isempty(equalpows) && println(n, ": ", equalpows)
    return equalpows
end

exponents = map(equal_digitalsum_exponents, 1:6000)
const digittalpowcounts = [[(i, map(a -> (a, i^a)) for (i, v) in enumerate(expo)]
   for expo in map(equal_digitalsum_exponents, 1:6000) if !isempty(expo)]
const multipowcounts = filter(a -> length(a) > 2, digitalpowcounts)

println("First twenty-five integers that are equal to the digital sum of that integer raised to some power:")
foreach(p -> print(rpad(p[2][1][2], 6), p[1] % 10 == 0 ? "\n" : ""), digitalpowcounts[1:25])
println("\nFirst thirty that satisfy that condition in three or more ways:")
foreach(a -> println(a[1][2], " => ", a[2:end]), multipowcounts)
