using Formatting, Primes

struct Sisyphus end

function base.iterate(s::Sisyphus, (n, p) = (1, 0)
    if p == 0
        return 1, (1, 1)
    else
        if isodd(n)
            p = nextprime(p + 1)
            n = n + p
        else:
            n = n  \div 2
        yield n, p


def consume(it: Iterator[Tuple[int, int]], n) -> Tuple[int, int]:
    next(islice(it, n - 1, n - 1), None)
    return next(it)


T = TypeVar("T")


def batched(it: Iterable[T], n: int) -> Iterable[Tuple[T, ...]]:
    _it = iter(it)
    batch = tuple(islice(_it, n))
    while batch:
        yield batch
        batch = tuple(islice(_it, n))


if __name__ == "__main__":
    it = sisyphus()
    first_100 = list(islice(it, 100))
    print("The first 100 members of the Sisyphus sequence are:")
    for row in batched(first_100, 10):
        print("  ".join(str(n).rjust(3) for n, _ in row))

    print("")

    for interval in [10**x for x in range(3, 9)]:
        n, prime = consume(it, interval - (interval // 10))
        print(f"{interval:11,}th number: {n:13,}   highest prime needed: {prime:11,}")

    print("")

    sisyphus_lt_250 = Counter(n for n, _ in islice(sisyphus(), 10**8) if n < 250)
    print("These numbers under 250 do not occur in the first 100,000,000 terms:")
    print(" ", [n for n in range(1, 250) if n not in sisyphus_lt_250])
    print("")

    most_common = sisyphus_lt_250.most_common(1)[0][1]
    print("These numbers under 250 occur the most in the first 100,000,000 terms:")
    print(
        f"  {[n for n, c in sisyphus_lt_250.items() if c == most_common]} "
        f"all occur {most_common} times."
    )


using Printf

function aitken(f, p0)
    p1 = f(p0)
    p2 = f(p1)
    return p0 - (p1 - p0)^2 / (p2 - 2 * p1 + p0)
end

function steffensen_aitken(f, pinit, tol, maxiter)
    p0 = pinit
    p = aitken(f, p0)
    iter = 1
    while abs(p - p0) > tol && iter < maxiter
        p0 = p
        p = aitken(f, p0)
        iter += 1
    end
    abs(p - p0) > tol && return NaN
    return p
end

function deCasteljau(c0, c1, c2, t)
    s = 1.0 - t
    return s * (s * c0 + t * c1) + t * (s * c1 + t * c2)
end

xConvexLeftParabola(t) = deCasteljau(2, -8, 2, t)
yConvexRightParabola(t) = deCasteljau(1, 2, 3, t)
implicit_equation(x, y) = 5x^2 + y - 5

f(t) = implicit_equation(xConvexLeftParabola(t), yConvexRightParabola(t)) + t

function test_steffensen(tol = 0.00000001, iters = 1000, stepsize = 0.1)
    for t0 in 0:stepsize:1
        @printf("t0 = %0.1f : ", t0)
        t = steffensen_aitken(f, t0, tol, iters)
        if isnan(t)
            @printf("no answer\n")
        else
            x = xConvexLeftParabola(t)
            y = yConvexRightParabola(t)
            if abs(implicit_equation(x, y)) <= tol
                @printf("intersection at (%f, %f)\n", x, y)
            else
                @printf("spurious solution\n");
            end
        end
    end
    return 0
end

test_steffensen()

function jp(limit::T) where T <: Integer
    res = map(factorial, T(1):T(18))
    k = 2
    while k < length(res)
        rk = res[k]
        for j = 2:length(res)
            kl = res[j] * rk
            kl > limit && break
            while kl <= limit && kl âˆ‰ res
                push!(res, kl)
                kl *= rk
             end
        end
        k += 1
    end
    return sort!((sizeof(T) > sizeof(Int) ? T : Int).(res))
end

@show jp(UInt(2^53))
@time jp(UInt(2^53))
