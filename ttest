

""" Blueprints from data file, each line has recipes for building robots """
struct Blueprint
    num::Int
    orecost::Int # in ore
    claycost::Int # in ore
    obsidian_orecost::Int
    obsidian_claycost::Int
    geode_orecost::Int
    geode_obsidiancost::Int
    Blueprint(arr::Vector{Int}) = new(arr...)
end
Blueprint(txtline) = Blueprint([parse(Int, s.match) for s in eachmatch(r"\d+", txtline)])

const blueprints = map(Blueprint, readlines("day19.txt"))

""" GeodeState, data for states for time series of building robots, collecting products """
mutable struct GeodeState
    minute::Int
    ore_robots::Int
    clay_robots::Int
    obsidian_robots::Int
    geode_robots::Int
    ore::Int
    clay::Int
    obsidian::Int
    geode::Int
    GeodeState() = new(0, 1, 0, 0, 0, 0, 0, 0, 0)
end

""" 
    forkstate(b::Blueprint, gvec::Vector{GeodeState})::Vector{Vector{GeodeState}}

    Given a set of states, return a vector of possible successor states,
    so that there are different variants of options taken for each item in list
"""
function forkstate(b::Blueprint, states)
    newstates = empty(states)
    for state in states
        g = deepcopy(state)
        g.minute += 1
        cangeoderobot = g.ore >= b.geode_orecost && g.obsidian >= b.geode_obsidiancost
        canobsidianrobot = g.ore >= b.obsidian_orecost && g.clay >= b.obsidian_claycost
        canclayrobot = g.ore >= b.claycost
        canorerobot = g.ore >= b.orecost
        g.ore += g.ore_robots
        g.clay += g.clay_robots
        g.obsidian += g.obsidian_robots
        g.geode += g.geode_robots
        if cangeoderobot
            g.ore -= b.geode_orecost
            g.obsidian -= b.geode_obsidiancost
            g.geode_robots += 1  # always add geode robot if can
            push!(newstates, g)
        elseif canobsidianrobot  # optional build obsidian robot case
            g = deepcopy(g)
            g.ore -= b.obsidian_orecost
            g.clay -= b.obsidian_claycost
            g.obsidian_robots += 1  
            push!(newstates, g)
        else
            push!(newstates, g)  # this case is for no robots built
            if canclayrobot # optional build clay robot case
                g2 = deepcopy(g)
                g2.ore -= b.claycost
                g2.clay_robots += 1
                push!(newstates, g2)
            end
            if canorerobot # optional build ore robot case
                g2 = deepcopy(g)
                g2.ore -= b.orecost
                g2.ore_robots += 1
                push!(newstates, g2)
            end
        end
    end
    return newstates
end

""" breadth-first simulation of the geode processing outcomes under each blueprint """
function simulate(blueprints = blueprints, minutes = 24, verbose = true)
    blen = length(blueprints)
    qualities = zeros(Int, blen)
    geodes = zeros(Int, blen)
    statelists = [[GeodeState()] for _ in 1:blen]
    for (i, b) in enumerate(blueprints)
        obdeadline = 19
        for m in 1:minutes
            statelists[i] = unique(forkstate(b, statelists[i]))
            verbose && @show b, m, length(statelists[i])
            m == obdeadline && filter!(s -> s.obsidian_robots > 0, statelists[i])
        end
        geodes[i] = maximum(s.geode for s in statelists[i])
        qualities[i] = geodes[i] * i
    end
    verbose && @show qualities
    return sum(qualities)
end

const part = [0, 0]
part[1] = simulate()
@show part # > 1809


#=
""" depth first search for maximum geode production for a given blueprint """
function depthfirst(state, blueprint, stepminute, maxminutes)
    newstates = forkstate(blueprint, [state])
    return stepminute >= maxminutes ? maximum(s -> s.geode, newstates) :
       maximum(s -> depthfirst(s, blueprint, stepminute + 1, maxminutes), newstates)
end

""" Part 1 search for the best geode production path for all blueprints and their sum """
function part1(blueprints = blueprints, maxminutes = 24, verbose = true)
    maxgeodes = zeros(Int, length(blueprints))
    for (i, b) in enumerate(blueprints)
        bestgeodecount = depthfirst(GeodeState(), b, 1, maxminutes)
        verbose && @show b, bestgeodecount
        maxgeodes[i] = bestgeodecount
    end
    part[1] = sum(maxgeodes)
    verbose && @show part
    return part[1]
end

part1()

=#

@show part
