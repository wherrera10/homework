// This version formats the encrypted text in 5 character blocks, as the historical version apparently did.

//use std::string;
use std::collections::HashMap;
use fastrand::shuffle;
use itertools::Itertools;

/// The WWI German ADFGVX cipher.
struct AdfgvxCipher {
    polybius: Vec<char>,
    alphabet: Vec<char>,
    key: Vec<char>,
    pdim: u32,
    keylen: u32,
    pairs: Vec<String>,
    encode: HashMap<char, String>,
    decode: HashMap<String, char>,
}

/// Set up the encoding and decoding for the ADFGVX cipher.
fn setup(a: AdfgvxCipher) {
    a.pdim = a.polybius.len().isqrt() as i32;
    a.keylen = a.key.len() as u32;
    a.pairs = a.polybius.iter().map(|c1| a.polybius.iter().map(|c2| "{c1}{c2}"));
    a.encode = HashMap::new();
    for (i, k) in a.polybius.iter().enumerate() {
        a.encode.insert(*k, a.pairs[i]);
    }
    a.decode = HashMap::new();
    for (i, (k, v)) in a.encode.iter().enumerate() {
        a.decode.insert(*v, *k);
    }
}

fn every_n_space(string: String, sub_len: usize) -> String {
    return string.as_str().as_bytes().chunks(sub_len).map(|a| "{a:?}").join(" ");
}

/// Encrypt with the ADFGVX cipher.
fn encrypt(a: AdfgvxCipher, msg: String) -> String {   
    let chars: Vec<char> = msg.to_uppercase().chars().filter_map(|c| a.encode.get(c).ok()).join("").collect();
    let mut colvecs = a.key.iter().enumerate().map(|i, k| (k, chars[i..chars.len().step_by(a.keylen)]));
    colvecs.sort();
    return every_n_space(colvecs.map(|p| p.1).join(""), 5);
}

/// Decrypt with the ADFGVX cipher. Does not depend on spacing of encoded text
fn decrypt(a: AdfgvxCipher, cod: String) -> String {
    let chars: Vec<char> = cod.chars().filter(|c| a.alphabet.contains(c));
    let sortedkey = a.key.clone().sorted();
    let order = sortedkey.map(|c| a.key.index(c));
    let originalorder = a.key.map(|c| sortedkey.index(c));
    let base = chars.len() / a.keylen;
    let extra = chars.len() % a.keylen;
    let strides = order.map(|i| if extra >= i {base + 1} else {base});  // shuffled column lengths
    let mut starts = vec![1_u32; 1].to_vec();                 // starting index is 0
    for i in 1..strides.len()-1 {
        starts.push(strides[i] + strides[i + 1]);                       // shuffled starts of columns
    }
    let ends = (0..a.keylen).iter().map(|i| starts[i] + strides[i]);    // shuffled ends of columns
    let cols = originalorder.iter().map(|i| chars[starts[i]..ends[i]]); // get reordered columns
    let pairs = vec![' '; 0].to_vec();                                                
    let nrows: u32 = chars.len() / a.keylen + 1;                        // recover the rows
    for i in 0..nrows {
        for j in 0.keylen {
            if i * a.keylen + j > chars.len() {
                break;
            }
            pairs.push(cols[j][i])
        }
    }
    return (0..pairs.len().step_by(2)).map(|i| a.decode[pairs[i] + pairs[i + 1]]).join("");
}

fn main() {
    let msg = "ATTACKAT1200AM";
    let pchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".to_uppercase()
       .chars().collect::<Vec<_>>();
    let polybius = pchars.clone();
    shuffle(&mut polybius);
    let key = "volcanism".to_uppercase().chars().collect::<Vec<_>>();
    let pairs = vec![""; 0].to_vec();
    let pdim = (polybius.len() as f64).sqrt().floor() as u32;
    let adf = AdfgvxCipher { polybius: polybius, alphabet: pchars,
        key: key, pdim: pdim, keylen: 9_i32, pairs: pairs, 
        encode: HashMap::new(), decode: HashMap::new() };
    setup(adf);
    let encrypted_message = encrypt(adf, msg);
    println!("Message: {original}");
    println!("Polybius: {polybius:?}, key: {key:?}");
    println!("Encoded: {encrypted_message}");
    let decoded = decrypt(adf, encrypted_message);
    println!("Decoded: {decoded:?}");
}
