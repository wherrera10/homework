use core::cmp::max;
use itertools::Itertools;

largest = [0]

fn iscolorful(n: u64) {
    if &n > 10 {
        let mut dig = c.to_string().collect();
        let products = dig.unique();
        if dig.len() > products.len() || dig.contains(1) || dig.contains(0) {
            return false;
        }
        for i in 0..dig.len() {
            for j in i+2..=dig.len() {
                p = (dig[i..j]).product();
                if products.contains(p) {
                    return false;
                }
                products.push(p);
            }
        }
    }
    return true;
}

fn test_colorful()
    print('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')
    for i in range(1, 101, 25):
        for j in range(25):
            if iscolorful(i + j):
                print!("{:5}{}", i + j, { if (i + j) % 10 == 0 { "\n" }; else { "" };);
            }
        }
    }
    println!()

    csum: u64 = 0;
    largest: u64 = 0;
    for i in 0..8 {
        j: u64 = { if(i == 0) { 0 }; else { 10 ** i }; 
        k = 10**(i+1) - 1;
        n = 0;
        for x in j..=k {
            if iscolorful(x) {
                largest = max(largest, x);
                n += 1
            }
        }
        csum += n
        println!("The count of colorful numbers between {j} and {k} is {n}.");
    }
    println!("The largest possible colorful number is {largest}.");
    println!("The total number of colorful numbers is {csum}.")
}

