using Distributed

const KeyUp, KeyDown, KeyLeft, KetRight = 259, 258, 260, 261
const  Mx = 69 # No of columns (1..Mx), must be odd.
const My = 31 # No of rows (1..My), must be odd.
const Treasure = '$'
const TreasureDb = 3 # How many $ signs will be placed.
const Way = ' '
const Wall = 'X'
const Doors = 20 # No of doors.
const DoorCenter = 'o'
const DoorWingVertical = '|'
const DoorWingHorizontal = '-'
const Hero = '@'
const DeadHero = '+'
const NumberOfBombs = 5
const Bomb = 'b'
const NumberOfMonsters = 20
const Monster = '*'
const WeakMonster = '.'
const MonsterWeaknessProbability = 25
    # The higher the above number, the lower the chance that a strong monster will become weak.
const MonsterIntensifiesProbability = 5
    # The higher the number above, the lower the chance that a weak monster will get stronger.
const HelpText = """
  Maze game.

The object of the game is to get all the treasures. The symbol of the treasure is the $ sign.
Help (display this text): press ? or h
Exit: press Esc or q
You can detonate a bomb by pressing b, but only as long as your bomb remains.
A bomb destroys every wall around the player (the outermost, framing of the maze
except for its walls), but it won't kill monsters.
The bomb does not destroy diagonally, only vertically and horizontally.
The bomb will not destroy the doors or the treasure.
You can also find bombs in the maze, represented by the letter b. If you step on them,
you got the bomb with it, that is, the number of your bombs increases, for later use.
The game ends when you have acquired all the treasures.
The maze has not only walls but also revolving doors.
The revolving door, if horizontal, looks like this: -o-
If vertical, like this:
 |
 o
 |
The center of the revolving door is represented by the character o, the wings by the line.
The revolving door can be rotated if you take your wing in the right direction with your character,
and if nothing stands in the way of rotation.
The player is represented by @ in the game, and his starting point is always in the lower left corner.
There is a possibility of a little cheating in the game: each press of the letter c is one increases
the amount of your bombs.
"""

@enum Direction dirLeft dirRight dirUp dirDown

const Position = NamedTuple{(:x, :y)}

mutable struct Game
    grid::Vector{Vector{Char}}
    scoords::Vector{Position}
    showHelp::Bool
    terminate::Bool
    treasureCounter::Int
    bombs::Int
    x::Int
    y::Int
end

const None = Position((0, 0))
const Dy = [-1, 1, 0, 0]
const Dx = [0, 0, -1, 1]
const gameLock::SpinLock

function genFlags(n::Int) = for i in 1:2:n result[i] = true; end

function Game()
    result = Game(Vector{Vector{Char}}(), Vector{Position()},
       false, false, 0, 0, 0, 0)

    result.bombs = 3
    for x in 1:Mx
        result.grid[1][x] = Wall
        result.grid[My][x] = Wall
    end
    for y in 2:My-1
         result.grid[y][1] = Wall
    end
    for x in 2:Mx-1
        result.grid[y][x] = Way
        result.grid[y][Mx] = Wall
    end
    colFlags = genFlags(Mx)
    rowFlags = genFlags(My)

    while colFlags.anyIt(it) or rowFlags.anyIt(it):
        direction = Direction(rand(3))
        j = rand(1:(direction <= dirRight ? My : Mx)) รท 2 * 2 + 1
    end
    if direction == dirLeft
        if rowFlags[j]
            for r in 1:Mx-1
                if result.grid[j][r] != Wall && result.grid[j][r+1] != Wall
                    result.grid[j][r] = Wall
                end
            end
            rowFlags[j] = false
        end
    elseif direction == dirRight
        if rowFlags[j]
             for r in Mx:-1:3
                if result.grid[j][r-1] != Wall && result.grid[j][r-2] != Wall
                    result.grid[j][r-1] = Wall
                end
            end
            rowFlags[j] = false
        end
    elseif direction == dirUp
        if colFlags[j]
            for c in My:-1:3
                if result.grid[c-1][j] != Wall && result.grid[c-2][j] != Wall
                    result.grid[c-1][j] = Wall
                end
            end
            colFlags[j] = false
        end
    elseif direction == dirDown
        if colFlags[j]
            for c in 1:My-1
                if result.grid[c][j] != Wall && result.grid[c+1][j] != Wall
                    result.grid[c][j] = Wall
                end
            end
            colFlags[j] = false
        end

    doorsPlaced = 0
    while doorsPlaced < Doors:
        x = rand(3:Mx-2)
        y = rand(3:My-2)
        if result.grid[y][x] != Way &&
            result.grid[y-1][x-1] == Way &&         # top left corner free
            result.grid[y-1][x+1] == Way &&         # top right corner free
            result.grid[y+1][x-1] == Way &&         # left corner free
            result.grid[y+1][x+1] == Way            # right corner free
                # Let's see if we can put a vertical door.
            if result.grid[y-1][x] == Wall &&         # wall above the current position
              result.grid[y-2][x] == Wall &&        # wall above the current position
              result.grid[y+1][x] == Wall &&        # wall below the current position
              result.grid[y+2][x] == Wall &&        # wall below the current position
              result.grid[y][x-1] == Way &&         # left neighbor free
              result.grid[y][x+1] == Way            # right neighbor free
                result.grid[y][x] = DoorCenter
                result.grid[y-1][x] = DoorWingVertical
                result.grid[y+1][x] = DoorWingVertical
                doorsPlaced += 1
                # Let's see if we can put a horizontal door.
            elseif result.grid[y][x-1] == Wall &&       # wall left of the current position
              result.grid[y][x-2] == Wall &&      # wall left of the current position
              result.grid[y][x+1] == Wall &&      # wall right of the current position
              result.grid[y][x+2] == Wall &&      # wall right of the current position
              result.grid[y+1][x] == Way  &&      # above neighbor free
              result.grid[y-1][x] == Way          # below neighbor free
                result.grid[y][x] = DoorCenter
                result.grid[y][x-1] = DoorWingHorizontal
                result.grid[y][x+1] = DoorWingHorizontal
                doorsPlaced += 1
            end
        end
    end  
    const Stuff = [(TreasureDb, Treasure),
      (NumberOfBombs, Bomb),
      (NumberOfMonsters, WeakMonster)]   # At first, all monsters are weak.

    for (n, what) in Stuff
        iter = 1
        nn = n
        while nn > 0
            x = rand(1:Mx)
            y = rand(1:My) 
            if result.grid[y][x] == Way
              result.grid[y][x] = what
            end
            if what == WeakMonster:
                result.scoords[n] = (x, y)
            nn -= 1
            iter += 1
            @assert iter <= 10_000 # (sanity check)
        end
    end
    result.x = 1
    result.y = My - 2
    result.grid[My - 2][1] = Hero
    return result
end

function draw!(game)
    cursSet(0)
    while true
        acquire(gameLock)
        if game.showHelp
            erase()
            addStr(HelpText)
            readline()
            erase()
            game.showHelp = false
        end
        erase()
        move(0, 0)
        for row in game.grid
            addstr(join(row)) * '\n'
        end
        addstr("\n\nCollected treasures = $(game.treasureCounter)     Bombs = $(game.bombs)\n")
        refresh()
        game.terminate && break
        release(gameLock)
        sleep 200
        release(gameLock)
    end
end

function monsterStepFinder(game, sx, sy)
    result = nothing
    var m = [0, 1, 2, 3]
    m.shuffle()
    for i in m
        nx = sx + Dx[i]
        ny = sy + Dy[i]
        if ny in 1:My && nx in 1:Mx && game.grid[ny][nx] in [Way, Hero]
            result = (nx, ny)
        end
    end
    return result
end

function monsterMove(game)
    while not game.terminate
        acquire gameLock
        active = rand(1..NumberOfMonsters)
        (sx, sy) = game.scoords[active]
        if sx != 0
            ch = game.grid[sy][sx]
        end
        if ch == Monster
            if rand(1:MonsterWeaknessProbability) == 1
                game.grid[sy][sx] = WeakMonster
            else
                monster = game.monsterStepFinder(sx, sy)
                if monster != nothing
                    if game.grid[monster.y][monster.x] == Hero
                        game.grid[monster.y][monster.x] = DeadHero
                        game.terminate = true
                    end
                end
                break
            end
            game.grid[sy][sx] = Way
            game.grid[monster.y][monster.x] = Monster
            game.scoords[active] = monster
        elseif ch == WeakMonster
            if rand(1..MonsterIntensifiesProbability) == 1:
                game.grid[sy][sx] = Monster
            else
                monster = game.monsterStepFinder(sx, sy)
                if monster != nothing
                    game.grid[sy][sx] = Way
                    if game.grid[monster.y][monster.x] != Hero:
                        game.grid[monster.y][monster.x] = WeakMonster
                        game.scoords[active] = monster
                    else
                        game.scoords[active] = nothing
                    end
                end
            end
        end
    end
    release gameLock
    sleep 100
    release gameLock
end

function rotateDoor!(game, nx, ny)
    for i in 1:4
        wy = Dy[i-1]
        wx = Dx[i-1]
        cy = ny + wy
        cx = nx + wx
        if game.grid[cy][cx] == DoorCenter
            if game.grid[cy-1][cx-1] == Way &&
              game.grid[cy-1][cx+1] == Way &&
              game.grid[cy+1][cx-1] == Way &&
              game.grid[cy+1][cx+1] == Way  # four corners empty
                py = Dy[end-i]
                px = Dx[end-i]
                if game.grid[cy+py][cx+px] == Way &&
                  game.grid[cy-py][cx-px] == Way  # swung door empty
                    door = game.grid[ny][nx]
                    flip = door == DoorWingVertical ? DoorWingHorizontal : DoorWingVertical
                    game.grid[cy+py][cx+px] = flip
                    game.grid[cy-py][cx-px] = flip
                    game.grid[cy+wy][cx+wx] = Way
                    game.grid[cy-wy][cx-wx] = Way
                end
            end
        end
        break
    end
end

function keyboard(game, win)
    while not game.terminate
        key = -1
        while key == -1 && !game.terminate
            sleep(10)
            key = wgetch(win)
            acquire(gameLock)
            if key in ['\e', 'q']
                game.terminate = true
            elseif key == 'b'
                if game.bombs != 0
                    dec game.bombs -= 1
                    for i in 0..3:
                        nx = game.x + Dx[i]
                        ny = game.y + Dy[i]
                        if ny in 2:My-1 && nx in 2:Mx-1 && game.grid[ny][nx] == Wall
                            game.grid[ny][nx] = Way
                        end
                    end
                end
            elseif key == 'c'
                  game.bombs += 1
            elseif key in ['?', 'h']
                game.showHelp = true
            else
                chIndex = findfirst(==(key), [KeyUp, Keydown, KeyLeft, KeyRight])
                if chIndex != nothing
                    nx = game.x + Dx[chIndex]
                    ny = game.y + Dy[chIndex]
                    if ny in 2:My-1 && nx in 2:Mx-1
                        ch = game.grid[ny][nx]
                        if ch in [DoorWingVertical, DoorWingHorizontal]
                            game.grid[game.y][game.x] = Way   # (temp. "ghost" him)
                            game.rotateDoor(nx, ny)
                            game.grid[game.y][game.x] = Hero
                            ch = game.grid[ny][nx]            # (maybe unaltered)
                        elseif ch == Monster
                            game.grid[game.y][game.x] = Way
                            game.grid[ny][nx] = DeadHero
                            game.y = ny
                            game.x = nx
                            game.terminate = true
                        elseif ch == Treasure
                            game.treasureCounter += 1
                            if game.treasureCounter == TreasureDb
                                game.terminate = true
                            end
                            ch = Way
                        elseif ch == Bomb:
                            game.bombs += 1
                            ch = Way
                        end
                        if ch in [Way, WeakMonster]
                            game.grid[game.y][game.x] = Way
                            game.grid[ny][nx] = Hero
                            game.y = ny
                            game.x = nx
                        end
                    end
                end
            end
        end
        release(gameLock)
    end
    while getch() != -1
        discard()   # (purge kbd buffer)
    end
end


function play()
    randomize()
    win = initscr()
    win.nodelay(true)
    win.keypad(true)
    noecho()
    cbreak()
    addExitProc proc() = endwin()
    addExitProc proc() = cursSet(1)
    game = initGame()

  var tdraw, tmove: Thread[ptr Game]
  createThread(tdraw, draw, addr(game))
  createThread(tmove, monsterMove, addr(game))
  game.keyboard(win)

  joinThreads(tdraw, tmove)
  if game.treasureCounter == TreasureDb:
    addstr "\nYOU WON! Congratulations!\n"
    refresh()
    while getch() == -1: sleep(1)
  elif game.grid[game.y][game.x] == DeadHero:
    addstr "\nYOU PERISHED!\n"
    refresh()
    while getch() == -1: sleep(1)


play()


