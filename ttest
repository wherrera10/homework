using Counters, Formatting, Primes

struct Sisyphus end

function Base.iterate(s::Sisyphus, (n, p) = (0, 0))
    if n == 0
        return (1, 0), (1, 0)
    else
        if isodd(n)
            p = nextprime(p + 1)
            n += p
        else
            n ÷= 2
        end
        return (n, p), (n, p)
    end
end

const coun = Counter{Int}()
println("The first 100 members of the Sisyphus sequence are:")
for (i, (n, p)) in enumerate(Sisyphus())
    if n < 250
        coun[n] += 1
    end
    if i < 101
        print(rpad(n, 4), i % 10 == 0 ? "\n" : "")
    elseif i in [1000, 10000, 100_000, 1_000_000, 10_000_000, 100_000_000]
        print("\n$(format(i, commas = true))th number: ", format(n, width = 13, commas = true),
           ".  Highest prime needed: ", format(p, commas = true))
    end
    if i == 100_000_000
        println("These numbers under 250 do not occur in the first 100,000,000 terms:")
        println("    ", filter(j -> !haskey(coun, j), 1:249), "\n\n")
        sorteds = sort!([p for p in counter], key = last)
        maxtimes = sorteds[end][2]
        println("These numbers under 250 occur the most ($maxtimes times) in the first 100,000,000 terms:")
        println("    ", map(last, filter(p[2] == maxtimes, sorteds)))
        break
    end
end

function sisyphus36()
    n, p, i = big"1", big"0", big"1"

    while true
        i += 1
        if isodd(n)
            p = nextprime(p + 1)
            n = n + p
        else
            n = n ÷ 2
        end
        if n == 36
            print(format(i, commas = true), " ", format(n, commas = true), " ",
                  format(p, commas = true))
            break
        end
    end
end

#@time sisyphus36()



using Printf

function aitken(f, p0)
    p1 = f(p0)
    p2 = f(p1)
    return p0 - (p1 - p0)^2 / (p2 - 2 * p1 + p0)
end

function steffensen_aitken(f, pinit, tol, maxiter)
    p0 = pinit
    p = aitken(f, p0)
    iter = 1
    while abs(p - p0) > tol && iter < maxiter
        p0 = p
        p = aitken(f, p0)
        iter += 1
    end
    abs(p - p0) > tol && return NaN
    return p
end

function deCasteljau(c0, c1, c2, t)
    s = 1.0 - t
    return s * (s * c0 + t * c1) + t * (s * c1 + t * c2)
end

xConvexLeftParabola(t) = deCasteljau(2, -8, 2, t)
yConvexRightParabola(t) = deCasteljau(1, 2, 3, t)
implicit_equation(x, y) = 5x^2 + y - 5

f(t) = implicit_equation(xConvexLeftParabola(t), yConvexRightParabola(t)) + t

function test_steffensen(tol = 0.00000001, iters = 1000, stepsize = 0.1)
    for t0 in 0:stepsize:1
        @printf("t0 = %0.1f : ", t0)
        t = steffensen_aitken(f, t0, tol, iters)
        if isnan(t)
            @printf("no answer\n")
        else
            x = xConvexLeftParabola(t)
            y = yConvexRightParabola(t)
            if abs(implicit_equation(x, y)) <= tol
                @printf("intersection at (%f, %f)\n", x, y)
            else
                @printf("spurious solution\n");
            end
        end
    end
    return 0
end

test_steffensen()

function jp(limit::T) where T <: Integer
    res = map(factorial, T(1):T(18))
    k = 2
    while k < length(res)
        rk = res[k]
        for j = 2:length(res)
            kl = res[j] * rk
            kl > limit && break
            while kl <= limit && kl ∉ res
                push!(res, kl)
                kl *= rk
             end
        end
        k += 1
    end
    return sort!((sizeof(T) > sizeof(Int) ? T : Int).(res))
end

@show jp(UInt(2^53))
@time jp(UInt(2^53))
