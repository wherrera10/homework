
"""
    function kmp_table(W)

input:
    an array of characters, W (the word to be analyzed)
output:
    an array of integers, T (the table to be filled)
define variables:
    an integer, i ← 2 (the current one-based position we are computing in T)
    an integer, j ← 0 (the additive to index i in W of the next character of the current candidate substring)
"""
function kmp_table(W)
    len = length(W)
    T = zeros(Int, len)
    # start with the second letter of W, looking for patterns in W
    i = 2
    while i < len
        j, maybematch = 0, true
        while maybematch
            # compute the longest proper prefix
            if W[i + j] == W[j + 1]
                T[i + j] = T[i + j - 1] + 1
            else
                T[i + j] = 0 # back to start
                maybematch = false
            end
            j += 1
            # avoid overshooting end with index
            if i + j > len
                maybematch = false
            end
        end
        
        # entry in T found, so begin at next starting point along W
        i += j
    end
    return T
end    

"""
    function kmp_search(S, W)
    
input:
    an array of characters, S (the text to be searched)
    an array of characters, W (the word sought)
output:
    an array of integers, P (positions in S at which W is found)

define variables (one based indexing in Julia differs from the Wikipedia example):
    an integer, j ← 1 (the position of the current character in S)
    an integer, k ← 1 (the position of the current character in W)
    an array of integers, T (the table, computed elsewhere)
"""
function kmp_search(S, W)
    lenW, lenS = length(W), length(S)    
    i, P = 1, Int[]      
    T = kmp_table(W) # get pattern table

    while i <= lenS - lenW + 1
        j = 1
        for j in 1:lenW
            if S[i + j - 1] != W[j]
                # pattern not found, so skip unnecessary inner loops
		i += T[j] + 1
                @goto next_i
            end
        end
	# found pattern so add to output
        push!(P, i)
        i += 1
	@label next_i
    end                
    return P    
end

function kmp_search(S, W)
    j, k, lenS, lenW = 1, 1, 0, length(S), length(W)
    P = Int[]
    T = kmp_table(W)
    while j <= lenS
        if W[k] == S[j]
            j += 1
            k += 1
            if k > lenW
                # occurrence found: if only first occurrence is needed, m ← j - k  may be returned here
                push!(P, j - k)
                k = T[k] # (T[length(W)] can't be -1)
	    end
        else
            k = T[k]
            if k < 1:
                j += 1
                k += 1
            end
	end
    end
    return P, nP
end

