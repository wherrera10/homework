function decrypt(s::String, k)
    chars = filter(c -> c in k.alphabet, uppercase(s))
    sortedkey = sort(k.key)
    order = [findfirst(c -> c == ch, k.key) for ch in sortedkey]
    originalorder = [findfirst(c -> c == ch, sortedkey) for ch in k.key]
    a, b = divrem(length(chars), k.klen)
    endpositions = [sum(i -> a + (b >= i ? 1 : 0), 1:k.klen) for i in order]
    sortedends = sort(endpositions, rev=true)
    strides = [ 1 + (i > 1 ? endpositions[i - 1] : 0) : endpositionss[i] for i in order]
    cols = [chars[strides[i]] for i in originalorder]
    pvec = [cols[i][j] for i in 1:k.klen, j in 1:sortedends[i]]
    return String([decode(pvec[i], pvec[i + 1], k) for i in 1:2:length(pvec)-1])
end

displaypoly(p) = println(Matrix(reshape(p, (:, isqrt(length(p))))))


struct ADFGVX
    polybius::Vector{Char}
    pdim::Int
    key::Vector{Char}
    keylen::Int
    alphabet::Vector{Char}
    encoding::Dict{Char, Vector{Char}}
    decoding::Dict{Vector{Char}, Char}
end

function ADFGVX(s, k, alph = "ADFGVX")
    alphabet = collect(uppercase(alph))
    chars = filter(c -> c in alphabet, collect(uppercase(s)))
    pdim = isqrt(length(chars))
    encoding::Dict = Dict(polybius[(i - 1) + j] => alphabet[i], alphabet[j] for i in 1:pdim, j in 1:pdim)
    decoding = Dict(last(p) => first(p) for p in encoding)
    @assert pdim^2 == length(chars) && pdim == length(alphabet)
    return ADFGVX(chars, pdim, k, length(k), alphabet, encoding, decoding)
end

