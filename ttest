function equal_exponenitial_digital_sums(n::Integer)
    equalpows = [BigInt(n)]
    npow, misses, nsum = big"2", 0, sum(digits(n))
    while misses < n + 20
        if sum(digits(n ^ npow)) == nsum
            push!(equalpows, n ^ npow)
        else
            misses += 1
        end
        npow += 1
    end
    length(equalpows) > 1 && println(equalpows)
    return equalpows
end

const digittalpowcounts = filter(a -> length(a) > 1, map(equal_exponenitial_digital_sums, 1:6000))
const multipowcounts = map(a -> length(a) > 2, digitalpowcounts)

println("First twenty-five integers that are equal to the digital sum of that integer raised to some power:")
foreach(p -> print(rpad(p[2][1], 5), p[1] % 10 == 0 ? "\n" : ""), digitalpowcounts[1:25])
println("\nFirst thirty that satisfy that condition in three or more ways:")
foreach(a -> println(a[1], " => ", a[2:end]), multipowcounts)

