

function aupto(lim::T, mx::T = zero(T)) where T <: Integer
    lim < 2 && return [one(T)]
    v, t = [one(T)], one(T)
    mx == 0 && (mx = lim)
    for k in 2:mx
        t *= k
        t > lim && break
        append!(v, [t * rest for rest in aupto(lim ÷ t, t)])
    end
    return unique(sort!(v))
end

const factorials = map(factorial, 2:18)

function factor_as_factorials(n::T) where T <: Integer
    m = n
    fac_exp = Tuple{Int, Int}[]
    for idx in length(factorials):-1:1
        empty!(fac_exp)
        for i in idx:-1:1
            expo = 0
            while m % factorials[i] == 0
                expo += 1
                m ÷= factorials[i]
            end
            if expo > 0
                push!(fac_exp, (i + 1, expo))
            end
        end
        m == 1 && return fac_exp
    end
    return fac_exp
end

const superchars = ["\u2070", "\u00b9", "\u00b2", "\u00b3", "\u2074",
                    "\u2075", "\u2076", "\u2077", "\u2078", "\u2079"]
super(n::Integer) = prod([superchars[i + 1] for i in reverse(digits(n))])

arr = aupto(2^53)

println("First 50 Jordan–Pólya numbers:")
foreach(p -> print(rpad(p[2], 6), p[1] % 10 == 0 ? "\n" : ""), enumerate(arr[1:50]))

println("\nThe largest Jordan–Pólya number before 100 million: ", arr[findlast(<(100_000_000), arr)])

for n in [800, 1800, 2800, 3800]
    println("The $(n)th Jordan-Pólya number is: $(arr[n])")
    println(join(map(t -> "($(t[1])!)$(super(t[2])))", factor_as_factorials(arr[n])), " x "))
end

