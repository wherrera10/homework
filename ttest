"""
Rosetta code task N-queens_minimum_and_knights_and_bishops
For optimizer details, see https://github.com/ERGO-Code/HiGHS
"""

import HiGHS
using JuMP
using LinearAlgebra

mstring(x, n) = (s = ""; for i in 1:n, j in 1:n s *= lpad(x[i, j] == 1 ? char : ' ', 3) * j == n ? "\n" : ""; end; s)

function diagonalelements(mat::Matrix{T}, i, j) where T
   nrows, ncols = size(mat)
   ondiagonals = T[]
   for row in 1:nrows
       if i != row
           k = row - i + j
           1 <= k <= ncols && push!(ondiagonals, mat[row, k])
           k = j + i - row
           1 <= k <= ncols && push!(ondiagonals, mat[row, k])
       end
   end
   return ondiagonals
end

function queensminimum(N, char = "Q")
    model = Model(HiGHS.Optimizer)
    @variable(model, x[1:N, 1:N], Bin)

    for i in 1:N
        @constraint(model, sum(x[i, :]) == 1)
        @constraint(model, sum(x[:, i]) == 1)
    end

    for i in -(N - 1):(N-1)
        @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)
        @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims = 1), i)) <= 1)
    end

    @objective(model, Min, sum(x))
    optimize!(model)

    solution = round.(Int, value.(x))
    minresult = sum(solution)
    return minresult, mstring(solution, N)
end

function bishopsminimum(N, char = "B")
    model = Model(HiGHS.Optimizer)
    @variable(model, x[1:N, 1:N], Bin)

    for i in -(N - 1):(N-1)
        @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)
        @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims = 1), i)) <= 1)
    end

    @objective(model, Min, sum(x))
    optimize!(model)

    solution = round.(Int, value.(x))
    minresult = sum(solution)
    return minresult, mstring(solution, N)
end

function knightsminimum(N, char = "N")
    knightdeltas = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]

    model = Model(HiGHS.Optimizer)

    # to simplify the constraints, embed the board of size N inside a board of size n + 4
    @variable(model, x[1:N+4, 1:N+4], Bin)

    @constraint(model, x[:, 1:2] .== 0)
    @constraint(model, x[1:2, :] .== 0)
    @constraint(model, x[:, N-1:N] .== 0)
    @constraint(model, x[N-1:N, :] .== 0)


    for i in 3:N-2, j in 3:N-2
        @constraint(model, x[i, j] + sum(x[i, j] .+ knightdeltas) >= 1)
        @constraint(model, x[i, j] * sum(x[i, j] .+ knightdeltas) == 0)
    end

    @objective(model, Min, sum(x))
    optimize!(model)

    solution = round.(Int, value.(x))
    minresult = sum(solution)
    return minresult, mstring(solution, N)
end

