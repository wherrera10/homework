#=
Most of the needed functions are already part of the existing Permutations module in Julia,
but, as requested in the task, equivalent non-package-requiring code follows.
=#

""" A Perm is a permutation in one-line form. `a` is a shuffled gapless 1-based range of Int. """
struct Perm
    a::Vector{Int}
    function Perm(arr::Vector{Int})
        if sort(arr) != collect(1:length(arr))
            error("$arr must be permutation of 1-based integer range")
        end
        return new(arr)
    end
end

""" Create an identity Perm for permutations of length n """
Perm(n::Int) = Perm(1:n)

""" Create a Perm from its cycle vectors """
function Perm(cycles, addsingles = true)
    elements = reduce(vcat, cycles)
    if addsingles
        for elem in filter(x -> !(x in elements), 1:maximum(elements))
        push!(cycles, [elem])
        push!(elements, elem)
        end
    end
    a = collect(1:length(elements))
    sort!(elements) != a && error("Invalid cycles <$cycles> for creating a Perm")
    for c in cycles
        len = length(c)
        for i in 1:len
            j, n = c[i], c[mod1(i + 1, len)]
            a[j] = n
        end
    end
    return Perm(a)
end

""" length of Perm """
Base.length(p::Perm) = length(p.a)

""" iterator interface for Perm """
Base.iterate(p::Perm, state = 1) = state > length(p) ? nothing : (p[state], state + 1)

""" index into a Perm """
Base.getindex(p::Perm, i::Int64) = p.a[i]

""" permutation signage for the Perm """
Base.sign(p::Perm) = isodd(count(c -> iseven(length(c), permcycles(p)))) ? -1 : 1

""" order of permutation for Perm """
order(p::Perm) = lcm(map(length, permcycles(p)))

""" Composition of Perm permutations with the * operator """
Base.:*(p1:: Perm, p2::Perm) = Perm([p1.a[p2.a[i]] for i in 1:length(p1)])

""" inverse of a Perm """
function Base.inv(p::Perm)
    a = zeros(Int, length(p))
    for i in 1:length(p)
        j = p.a[i]
        a[j] = i
    end
    return Perm(a)
end

""" Get the Perm that functions to change one permutation result to another """
transform(p1::Perm, p2::Perm) = inv(p1) * p2

""" Get cycles of a Perm permutation as a vector of integer vectors, optionally with singles """
#= Generally, in Julia the package Permtations.jl will be used here. As suggested in the task, thecode
below will not use the standard package and will be from scratch istead. 
=#

function permcycles(p::Perm)
    v, cycles = p.a, Vector{Vector{Int}}()
    remaining, i = trues(length(v)), 1
    while i !== nothing
        remaining[i] = false
        c = [i]
        j = v[i]
        while j != i
            push!(c, j)
            remaining[j] = false
            j = v[j]
        end
        push!(cycles, c)
        i = findfirst(remaining)
    end
    return cycles
end

""" Perm prints in cycle or optionally oneline format """
function Base.print(io::IO, p::Perm; oneline = false, printsinglecycles = false)
    if length(p) == 0
        print(io, "()")
    end
    if oneline
        print(io, prod(map(n -> rpad(n, 4), p.a)))
    else
        cycles = permcycles(p, includesingles = printsinglecycles)
        print(io, prod(c -> "(" * string(c)[begin+1:end-1] * ")", cycles))
    end
end

""" Create a Perm from an iterable, eg. a string with only one of each of its letters """
function Perm(any_iterable)
    items = unique(collect(any_iterable))
    itemtoint = Dict(p[2] => p[1] for p in enumerate(items))
    return Perm([itemtoint[c] for c in items])
end

""" Given an iterable of equal length and a Perm, return a permuted vector of the iterable's elements """
function permuted(iterable, p1::Perm)
    p2 = Perm(iterable)
    inttoitem = Dict(enumerate(iterable))
    return [inttoitem(i) for i in (p1 * p2).a]
end

function testAlfBettyPerms()
    daysofweek = Dict{String, String}(
        "Mon" => "HANDYCOILSERUPT",
        "Tue" => "SPOILUNDERYACHT",
        "Wed" => "DRAINSTYLEPOUCH",
        "Thu" => "DITCHSYRUPALONE",
        "Fri" => "SOAPYTHIRDUNCLE",
        "Sat" => "SHINEPARTYCLOUD",
        "Sun" => "RADIOLUNCHTYPES"
    )
    WedThu = transform(Perm(daysofweek["Wed"]), Perm(daysofweek["Thu"]))

    print("On Thursdays Alf and Betty should rearrange\ntheir letters using these cycles: ")
    println(WedThu)
    println("So that $(daysofweek["Wed"]) becomes $(daysofweek["Thu"])")
    print("or they could use the one-line notation: ")
    print(stdout, WedThu; oneline = true)
    print("\n\nTo revert to the Wednesday arrangement they\nshould use these cycles: ")

    ThuWed = transform(Perm(daysofweek["Thu"]), Perm(daysofweek["Wed"]))

    println(ThuWed)
    print("or with the one-line notation" )
    print(stdout, ThuWed; oneline = true)
    println("So that $(daysofweek["Thu"]) becomes $(daysofweek["Wed"])")
    println("Starting with the Sunday arrangement and\napplying each of the daily permutations")
    println("consecutively, the arrangements will be:\n")
    println(" "^6, Sun, "\n")
    for day in ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        println(day, ":  ", dayofweek[day], day == "Sat" ? "\n" : "")
    end

    WedFri = transform(Perm(daysofweek["Wed"]), Perm(daysofweek["Fri"]))

    print("To go from Wednesday to Friday in a\nsingle step they should use these cycles: ")
    println(WedFri)
    println("So that $(daysofweek["Wed"]) becomes $(daysofweek["Fri"])")

    println("These are the signatures of the permutations:\n\n Mon Tue Wed Thu Fri Sat Sun")
    for day in ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        print(rpad(sign(daysofweek[day]), 4))
    end
    println("These are the orders of the permutations:\n\nMon Tue Wed Thu Fri Sat Sun")
    for day in ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        print(rpad(order(daysofweek[day]), 4))
    end
    println("Applying the Friday cycle to a string 10 times:\n")
    println("   ", daysofweek["Fri"], "\n")
    for i in 1:10
        println(lpad(i, 2), " ", i == 9 ? "\n" : "")
    end
end

testAlfBettyPerms()
